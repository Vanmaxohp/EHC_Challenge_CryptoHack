<img width="761" alt="image" src="https://github.com/Vanmaxohp/EHC_Challenge_CryptoHack/assets/90485791/800978e5-b865-479f-bcbe-e3d90fb6ae28">

Đề bài cho ta góc nhìn tổng quan về thuật toán [Tonelli-Shanks](https://rosettacode.org/wiki/Tonelli-Shanks_algorithm) để tính căn của thặng dư bậc hai.
Từ những gì tìm hiểu được trên google, thì thuật toán Tonelli-Shank gồm các bước như sau:
- Input: Nhập vào số nguyên n và số nguyên tố p
- Bước 1: Kiểm tra xem n có phải là thặng dư bậc hai modulo p hay không bằng ký hiệu Legendre.
- Bước 2: Phân tích thừa số 2 khỏi (p - 1): p - 1 = q * 2 ** S (q lẻ). Nếu p = 3 mod 4 (ví dụ: khi s = 1) thì trả về r ≡ ± n ** ((p + 1) / 4)
- Bước 3: Chọn một số z không phải thặng dư bậc hai (modulo p (z | p) = -1) và đặt c = z ** q mod p
- Bước 3: Đặt r = n ** ((q + 1) / 2) mod p, t = n ** q mod p, m = s
- Bước 4: Chạy vòng lặp:
  - Nếu t = 1 mod p, trả về r và p - r
  - Nếu không thì tim i nhỏ nhất thuộc khoảng (0, m) sao cho t ** 2 ** i = 1 mod p
  - Đặt b = c ** 2 ** (m - i - 1); r = rb, t = t * b ** 2, c = b ** 2 và m = i
Nếu p = 3 mod 4, r = +/- n ** ((p + 1) / 4), nếu chúng thoả mãn r ** 2 = n mod p thì chúng là nghiệm duy nhất, còn không thì không phải là căn thặng dư bậc hai modulo p.
Xem thêm: [Cách chứng minh thuật toán Tonelli-Shanks](https://en.wikipedia.org/wiki/Tonelli–Shanks_algorithm)

Từ ý tưởng đã google được ở trên, ta viết được chương trình python để thực hiện thuật toán:
```
#!/usr/bin/env python3

from Crypto.Util.number import *

def legendre(a, p):
	return pow(a, (p - 1) // 2, p) #ky hieu Legendre

def tonelli(n, p):
	if legendre(n, p) == 1:					#Kiem tra xem co phai thang du bac hai hay ko		
		q = p - 1
		s = 0
	while q % 2 == 0:						#Tim s, q sao cho p - 1 = q * 2 ** s
		q //= 2								#Chia 2 den khi thuong la so le	
		s += 1 								#So mu s la so lan da thuc hien phep chia 2
	if s == 1:								#Neu s = 1, r = +/- n ** ((p -1) / 4)
		return pow(n, (p + 1) // 4, p) 		
	for z in range(2, p):  					#Chon z 
		if legendre(z, p) == p - 1:			# (z | p) = -1 <=> (z | p) = p - 1;
			break
	c = pow(z, q, p)						#Buoc 3
	r = pow(n, (q + 1) // 2, p)				#
	t = pow(n, q, p)						#
	m = s 									#
	t2 = 0
	while t % p != 1:						#Chay vong lap neu t mod p != 1, neu khong thi tra ve r
		t2 = (t * t) % p  					#Tim i sao cho t ** 2 ** i mod p = 1, o day i bat dau tu 1
		for i in range(1, m):
			if t2 % p == 1:
				break
			t2 = (t2 * t2) % p  			#Tiep tuc mu 2 de i tang dan
		b = pow(c, pow(2, m - i -1), p)		#Dat cac tham so theo yeu cau cua thuat toan
		r = (r * b) % p
		c = (b * b) % p
		t = (t * c) % p
		m = i
	return r

n = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768
p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161

r = tonelli(n, p)

if (r * r) % p == n: 					#
	#print("n = %d p = %d" % (n, p))
	print("%d\n%d" % (r, p - r)) 			#Tra ve r vaf p - r
```
Chạy đoạn code trên, ta thu được 2 số: `2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120` và `28169512554311284614348161812907461395482195258388583125795498809297226147214152907614055638917789190356917578259717792167302913007927989841763977292434488782635964253677743342038748567333074043589267896292373028724763808006697707070301035339291758998923066001985927788808579330075671953036025191791621915640175242425390397212674797332132801882880223506177201168864920484993546017284338829512010922075018689505381642887042980971582058343875078178836965895987271392081926458392283354971823611423820865651283490761548053384731721391637064349021755899877224522161311561209530712702153163501623531290150340903913036821041`


<img width="960" alt="image" src="https://github.com/Vanmaxohp/EHC_Challenge_CryptoHack/assets/90485791/5b124fa6-07ea-4a6d-aedc-c6c29684d841">
